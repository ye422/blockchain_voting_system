서버리스 이메일 인증 기반 블록체인 투표 시스템 아키텍처 제안
1. 개요
본 문서는 기존 블록체인 투표 시스템의 더미(dummy) 신원 인증 기능을 서버리스 아키텍처를 활용한 이메일 기반 인증 시스템으로 고도화하는 것을 목표로 합니다. 별도의 백엔드 서버 운영 없이, 무료로 사용 가능한 외부 서비스를 조합하여 안전하고 효율적이며 확장 가능한 시스템을 구축하는 방안을 제안합니다.
2. 요구사항 정리
본 아키텍처가 충족해야 할 핵심 요구사항은 다음과 같습니다.
신원 인증 방식:
특정 도메인(@exampleuniv.ac.kr)을 사용하는 이메일 주소로 인증 코드를 발송하여 본인임을 확인해야 합니다.
고유성 보장:
하나의 유효 이메일 주소는 단 하나의 메타마스크 지갑 주소에만 바인딩(Binding)되어야 합니다.
이미 인증에 사용된 이메일 주소나 지갑 주소는 재사용할 수 없어야 합니다.
인프라 아키텍처:
별도의 서버(EC2, on-premise 등)를 직접 운영하지 않는 완전 서버리스(Serverless) 구조여야 합니다.
개발, 테스트, 초기 운영 단계에서 비용이 발생하지 않는 무료 서비스를 우선적으로 활용해야 합니다.
데이터 보안:
데이터베이스에 사용자의 개인 식별 정보(PII)인 이메일 주소와 지갑 주소가 평문(Plain Text)으로 저장되어서는 안 됩니다.
SBT 발급 권한을 가진 Verifier의 개인키는 코드나 외부에 노출되지 않고 안전하게 관리되어야 합니다.
3. 제안 아키텍처
요구사항을 모두 만족시키기 위해 Vercel을 중심으로 **Supabase(DB)**와 **Resend(Email)**를 연동하는 무료 서버리스 스택을 제안합니다.
3.1. 시스템 구성도
code
Code
┌─────────────────────────────────────────────────────────────────┐
│              Blockchain Voting System (Free Serverless)         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │               Frontend + Backend Logic (Vercel)            │  │
│  │  ┌─────────────────────────────────────────────────────┐ │  │
│  │  │  Frontend (React)                                   │ │  │
│  │  │   - 이메일/인증코드 입력 UI                           │ │  │
│  │  └─────────────────────────────────────────────────────┘ │  │
│  │  ┌─────────────────────────────────────────────────────┐ │  │
│  │  │  Serverless Functions (/api/*)                      │ │  │
│  │  │   - 인증 요청 처리, DB 조회, 이메일 발송, 서명 생성     │ │  │
│  │  └─────────────────────────────────────────────────────┘ │  │
│  └───────────────────────────┬──────────────────────────────┘  │
│                              ↓ ↑ (API Calls)                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                     External Free Services               │  │
│  │  ┌──────────────┐   ┌──────────────┐   ┌────────────────┐  │  │
│  │  │   Supabase   │   │   Resend     │   │ Vercel Env Vars│  │  │
│  │  │ (Hashed Data)│   │ (Email Delivery) │   │ (Secret Keys)  │  │  │
│  │  └──────────────┘   └──────────────┘   └────────────────┘  │  │
│  └──────────────────────────────────────────────────────────┘  │
│                              ↓ (Signed Data to Frontend)         │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                   Smart Contracts (on Quorum)            │  │
│  │  - CitizenSBT: Verifier의 서명을 검증하여 SBT 발급        │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
3.2. 핵심 구성 요소 및 역할
Vercel (통합 플랫폼)
역할: React 프론트엔드 배포, 서버리스 함수 실행, 환경 변수 관리를 모두 담당합니다.
Frontend: 기존의 React 애플리케이션을 호스팅합니다.
Serverless Functions: 프로젝트 내 /api 디렉토리의 파일들이 백엔드 로직을 수행하는 API 엔드포인트가 됩니다. (e.g., /api/request-code, /api/verify-and-sign)
Environment Variables: Verifier의 개인키, DB 접속 정보, 이메일 서비스 API 키 등 민감한 정보를 암호화하여 안전하게 저장합니다.
Supabase (데이터베이스)
역할: 사용자의 인증 상태를 영구적으로 관리하여 중복 등록을 방지합니다.
저장 데이터:
email_hash: 사용자의 이메일 주소를 솔트(Salt)와 함께 해싱한 값.
wallet_address_hash: 사용자의 지갑 주소를 솔트(Salt)와 함께 해싱한 값.
특징: 원본 데이터를 저장하지 않으므로 데이터 유출 시에도 개인정보가 안전하게 보호됩니다.
Resend (이메일 서비스)
역할: 사용자에게 일회용 인증 코드를 담은 이메일을 발송합니다.
특징: 개발자 친화적인 API를 제공하며, 개인 프로젝트에 충분한 무료 발송량을 제공합니다.
Smart Contracts (온체인 로직)
역할: 최종적인 SBT 발급을 담당합니다.
CitizenSBT.sol 변경점: mint 함수가 mintWithSignature 함수로 대체됩니다. 이 함수는 사용자로부터 Verifier의 서명을 받아, 해당 서명이 유효할 경우에만 SBT를 발급합니다.
3.3. 핵심 데이터 흐름 (인증 및 SBT 발급)
인증 요청: 사용자가 프론트엔드에서 이메일을 입력하면, 프론트엔드는 Vercel의 /api/request-code 함수를 호출합니다.
중복 검사 및 코드 발송: 서버리스 함수는 받은 이메일과 지갑 주소를 해싱하여 Supabase DB에서 중복 여부를 확인합니다. 중복이 없으면 인증 코드를 생성하여 Resend를 통해 사용자 이메일로 발송합니다.
코드 검증 및 서명: 사용자가 인증 코드를 입력하면, 프론트엔드는 /api/verify-and-sign 함수를 호출합니다.
서명 생성: 서버리스 함수는 코드의 유효성을 검증한 후, Vercel 환경 변수에 저장된 Verifier의 개인키를 이용해 SBT 발급에 필요한 데이터에 암호화 서명을 생성합니다.
서명 전달: 생성된 서명(signature)과 신원 해시(identityHash)가 프론트엔드로 반환됩니다.
SBT 발급: 프론트엔드는 사용자의 지갑(MetaMask)을 통해 CitizenSBT 컨트랙트의 mintWithSignature 함수를 호출하며, 전달받은 서명을 인자로 넘깁니다.
온체인 검증: 스마트 컨트랙트는 내장된 Verifier의 공개 주소를 이용해 서명을 검증하고, 유효성이 확인되면 호출한 사용자에게 SBT를 최종적으로 발급합니다.
3.4. 보안 설계
Verifier 개인키 관리: 개인키는 **Vercel의 암호화된 환경 변수(Secret)**에 저장됩니다. 오직 서버리스 함수 내부에서만 접근 가능하며, 프론트엔드나 외부로는 절대 노출되지 않습니다.
사용자 데이터 보호: 이메일과 지갑 주소는 **솔트를 이용해 해싱(Salted Hashing)**된 상태로 Supabase DB에 저장됩니다. 이를 통해 데이터베이스가 유출되더라도 원본 개인정보를 복원하는 것이 불가능합니다.
API 요청 제한 (Rate Limiting): `/api/request-code` 엔드포인트에 대한 무분별한 호출을 방지하기 위해 IP 주소 또는 지갑 주소 기반의 요청 횟수 제한(Rate Limiting)을 적용해야 합니다. 이는 악의적인 사용자가 Resend의 무료 이메일 발송량을 고갈시켜 서비스 장애를 유발하는 것을 막습니다. Vercel의 내장 기능을 활용하여 구현할 수 있습니다.
인증 코드 유효 시간 설정: 발급된 인증 코드는 보안을 위해 짧은 유효 시간(예: 5분)을 가져야 합니다. Supabase 테이블에 `code_expires_at`과 같은 타임스탬프 필드를 추가하고, 코드 검증 API(`/api/verify-and-sign`)에서 현재 시간이 만료 시간 이전인지 확인하는 로직이 필요합니다.
서명 재사용 방지 (Replay Attack Prevention): Verifier가 생성한 서명은 단 한 번만 온체인 트랜잭션에 사용되어야 합니다. 이를 위해, 서명할 데이터에 `identityHash`나 별도의 `nonce` 값을 포함시키고, `CitizenSBT` 스마트 컨트랙트가 이미 사용된 `nonce`나 `identityHash`를 기록하여 동일한 서명이 두 번 이상 사용되는 것을 막아야 합니다. 이는 재전송 공격을 효과적으로 방지합니다.

3.5. 트랜잭션 안정성 및 재시도 로직

트랜잭션 관점에서의 안정성은 분산 시스템에서 매우 중요합니다. 제안된 아키텍처는 Supabase의 강력한 트랜잭션 지원과 함께, 분산 시스템의 특성을 고려한 상태 관리 및 재시도 로직을 통해 안정성을 확보합니다.

### Supabase 자체의 트랜잭션 안정성

Supabase는 내부적으로 PostgreSQL을 사용하며, PostgreSQL은 수십 년간 검증된 강력한 관계형 데이터베이스(RDBMS)입니다. 이는 **ACID(원자성, 일관성, 고립성, 지속성)**를 완벽하게 지원합니다.

*   **원자성(Atomicity):** `INSERT`, `UPDATE` 등의 단일 쿼리는 하나의 트랜잭션으로 처리됩니다. 쿼리가 성공적으로 완료되거나, 실패하면 아예 실행되지 않은 상태로 롤백됩니다.
*   **일관성(Consistency):** `PRIMARY KEY`나 `UNIQUE` 제약 조건(예: `email_hash`는 중복 불가)을 설정하면, 데이터베이스가 스스로 데이터의 일관성을 보장합니다. 중복된 데이터를 삽입하려는 시도는 DB 레벨에서 자동으로 거부됩니다.

따라서 Supabase DB에 데이터를 쓰고 읽는 과정 자체의 안정성은 매우 높습니다.

### "인증 플로우" 전체의 트랜잭션 관점 분석 및 재시도 로직

사용자 인증 플로우는 여러 단계로 나뉘어 있으며, DB 작업과 블록체인 작업은 별개의 시스템에서 일어나므로 원자적으로 묶을 수 없습니다. 따라서 오류 발생을 상정하고, 상태(Status) 관리를 통해 최종 일관성(Eventual Consistency)을 보장하는 것이 표준적인 해결책입니다.

**오류 시나리오: DB 등록은 성공했지만, 블록체인 트랜잭션이 실패한 경우**

*   **상황:**
    *   사용자가 인증 코드를 정확히 입력했습니다.
    *   서버리스 함수가 Supabase DB에 `verified_users`로 해당 유저를 성공적으로 등록했습니다.
    *   서명을 프론트엔드로 반환했습니다.
    *   사용자가 MetaMask에서 `mintWithSignature` 트랜잭션을 보냈으나, 가스비 부족, 네트워크 오류, 또는 사용자의 거부(Reject) 등으로 블록체인 트랜잭션이 실패(revert)했습니다.
*   **문제:** DB에는 사용자가 인증된 것으로 기록되어 있지만, 실제 SBT는 발급받지 못한 상태가 됩니다. 이 사용자는 나중에 다시 시도하려고 해도, DB에 이미 등록되어 있으므로 `/api/request-code` 단계에서 "이미 등록된 사용자"로 처리되어 막히게 됩니다. 이것이 바로 트랜잭션 불일치 문제입니다.

**해결 방안: 상태(Status) 필드 추가 및 재시도 로직 구현**

이 문제를 해결하기 위해 DB 스키마를 다음과 같이 설계할 수 있습니다.

**개선된 Supabase 스키마:**

```sql
CREATE TABLE verified_users (
  email_hash TEXT PRIMARY KEY,
  wallet_address TEXT NOT NULL UNIQUE, -- 지갑 주소는 평문으로 저장 (재시도 편의성 위함)
  status TEXT NOT NULL DEFAULT 'PENDING', -- 상태: PENDING, COMPLETED
  signature TEXT, -- 재시도를 위한 서명값 저장
  identity_hash TEXT, -- 재시도를 위한 신원 해시 저장
  created_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ
);
```

*   **`wallet_address`를 평문으로 저장하는 이유:** 이 스키마에서는 사용자가 SBT 발급에 실패했을 때, 자신의 지갑 주소로 다시 인증 상태를 조회하고 재시도할 수 있도록 편의성을 제공하기 위함입니다. 만약 익명성이 더 중요하다면 이 또한 해싱할 수 있지만, 재시도 로직이 복잡해집니다.
*   **`status` 필드:**
    *   `PENDING`: 이메일 인증은 완료되었으나, 아직 SBT 발급(온체인 트랜잭션)은 확인되지 않은 상태.
    *   `COMPLETED`: SBT 발급이 최종적으로 완료된 상태.
*   **`signature`, `identity_hash` 필드:** 실패 시 재시도를 위해 서버가 생성한 서명과 해시를 저장합니다.

**개선된 워크플로우:**

1.  **`verify-and-sign` 함수:**
    *   인증 성공 시, DB에 사용자를 `status: 'PENDING'`으로 저장하고, 생성된 `signature`와 `identity_hash`도 함께 저장합니다.
    *   프론트엔드로 `signature`와 `identity_hash`를 반환합니다.
2.  **프론트엔드:**
    *   사용자가 트랜잭션을 성공적으로 보내면, **트랜잭션 영수증(receipt)**을 받습니다.
    *   영수증을 받으면, `/api/complete-verification`과 같은 새로운 엔드포인트를 호출하여 DB의 상태를 `COMPLETED`로 업데이트해달라고 요청합니다.
3.  **재시도 로직 (만약 실패했다면):**
    *   사용자가 나중에 다시 투표 페이지에 접속합니다.
    *   프론트엔드는 사용자의 지갑 주소로 `/api/check-status` 엔드포인트를 호출합니다.
    *   서버리스 함수는 DB에서 해당 지갑 주소를 조회하여 `status`가 `PENDING`인지 확인합니다.
    *   만약 `PENDING` 상태라면, DB에 저장된 `signature`와 `identity_hash`를 다시 프론트엔드로 보내줍니다.
    *   사용자는 SBT 발급을 재시도할 수 있습니다.

이러한 상태 관리 방식을 도입하면, 사용자가 도중에 오류를 겪더라도 안전하게 프로세스를 재개할 수 있어 전체 시스템의 안정성과 사용자 경험이 크게 향상됩니다. 이는 분산 시스템 설계의 기본 원칙 중 하나입니다.